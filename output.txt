diff --git a/src/main/java/frc/robot/Robot.java b/src/main/java/frc/robot/Robot.java
index 7047033..ca745c1 100644
--- a/src/main/java/frc/robot/Robot.java
+++ b/src/main/java/frc/robot/Robot.java
@@ -7,6 +7,7 @@
 
 package frc.robot;
 
+import edu.wpi.first.wpilibj.AnalogInput;
 import edu.wpi.first.wpilibj.DriverStation;
 import edu.wpi.first.wpilibj.TimedRobot;
 import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
@@ -41,6 +42,8 @@ public class Robot extends TimedRobot {
     //flag to indicate the real match
     private Boolean bRealMatch;
 
+    AnalogInput analogInput;
+
     /**
      * Determines if the robot is in a real match.
      *
@@ -121,6 +124,8 @@ public class Robot extends TimedRobot {
 
         logger.addHandler(Config.logFileHandler);
 
+        analogInput = new AnalogInput(3);
+
     }
 
     /**
@@ -211,7 +216,12 @@ public class Robot extends TimedRobot {
     @Override
     public void testPeriodic() {
 
+
+
         CommandScheduler.getInstance().run();
+
+
+        SmartDashboard.putNumber("Analog Light Sensor", analogInput.getValue());
     }
 
     @Override
diff --git a/src/main/java/frc/robot/RobotContainer.java b/src/main/java/frc/robot/RobotContainer.java
index 43fdf60..b6c08da 100644
--- a/src/main/java/frc/robot/RobotContainer.java
+++ b/src/main/java/frc/robot/RobotContainer.java
@@ -10,6 +10,7 @@ package frc.robot;
 import edu.wpi.first.wpilibj.GenericHID;
 import edu.wpi.first.wpilibj.Joystick;
 import edu.wpi.first.wpilibj.XboxController;
+import edu.wpi.first.wpilibj2.command.PrintCommand;
 import edu.wpi.first.wpilibj2.command.button.JoystickButton;
 import frc.robot.commands.*;
 import frc.robot.commands.OperatorIntakeCommand;
@@ -17,6 +18,7 @@ import frc.robot.commands.SpinUpShooter;
 import frc.robot.config.Config;
 import frc.robot.config.XboxValue;
 import frc.robot.sensors.AnalogSelector;
+import frc.robot.subsystems.ArmSubsystem;
 import frc.robot.subsystems.DriveBase;
 import frc.robot.commands.ArcadeDriveWithJoystick;
 import frc.robot.commands.DriveWithTime;
@@ -46,9 +48,10 @@ public class RobotContainer {
   private Command driveCommand;
   private Command intakeCommand;
   private Command emptyFeederCommand;
-  private Command incrementFeederCommand;
+    private Command reverseFeeder;
+  private Command moveArm;
   private Command rampShooterCommand;
-  private Command sensitiveDriverControlCommand;
+  private Command incrementFeeder;
   private Logger logger = Logger.getLogger("RobotContainer");
   private final double AUTO_DRIVE_TIME = 1.0;
   private final double AUTO_LEFT_MOTOR_SPEED = 0.2;
@@ -66,6 +69,9 @@ public class RobotContainer {
         if (Config.ANALOG_SELECTOR_TWO != -1) {
             analogSelectorTwo = new AnalogSelector(Config.ANALOG_SELECTOR_TWO);
         }
+
+        ArmSubsystem armSubsystem = ArmSubsystem.getInstance();
+
         configureButtonBindings();
     }
 
@@ -78,26 +84,43 @@ public class RobotContainer {
     private void configureButtonBindings() {
         driverStick = new Joystick(0);
         controlStick = new Joystick(1);
-        
+
         /**
          * Select drive mode for robot
          */
       
         // Instantiate the intake command and bind it
         intakeCommand = new OperatorIntakeCommand();
-        new JoystickButton(driverStick, XboxController.Button.kBumperLeft.value).whenHeld(intakeCommand);
+        new JoystickButton(controlStick, XboxController.Button.kBumperLeft.value).whenHeld(intakeCommand);
+
+        emptyFeederCommand = new EmptyFeeder();
+        new JoystickButton(controlStick, XboxController.Button.kB.value).whenHeld(emptyFeederCommand);
+
+        reverseFeeder = new ReverseFeeder();
+        new JoystickButton(controlStick, XboxController.Button.kX.value).whenHeld(reverseFeeder);
 
         // Instantiate the shooter ramping command and bind it
-        rampShooterCommand = new SpinUpShooter();
-        new JoystickButton(driverStick, XboxController.Button.kA.value).whenHeld(rampShooterCommand);
+//        rampShooterCommand = new SpinUpShooter();
+//        new JoystickButton(driverStick, XboxController.Button.kA.value).whenHeld(rampShooterCommand);
 
-        driveCommand = new ArcadeDriveWithJoystick(driverStick, Config.LEFT_CONTROL_STICK_Y, Config.INVERT_FIRST_AXIS, Config.RIGHT_CONTROL_STICK_X, Config.INVERT_SECOND_AXIS);
+        driveCommand = new ArcadeDriveWithJoystick(driverStick, Config.LEFT_CONTROL_STICK_Y, Config.INVERT_FIRST_AXIS, Config.RIGHT_CONTROL_STICK_X, Config.INVERT_SECOND_AXIS, true);
         DriveBase.getInstance().setDefaultCommand(driveCommand);
 
-        sensitiveDriverControlCommand = new SensitiveDriverControl(driverStick);
+        rampShooterCommand = new SpinUpShooter();
+        new JoystickButton(controlStick, XboxController.Button.kA.value).whenHeld(rampShooterCommand);
+
+//        moveArm = new MoveArmManuallyCommand();
+//        new JoystickButton(driverStick, XboxController.Button.kX.value).whenHeld(moveArm);
+
+//        incrementFeeder = new IncrementFeeder();
+//        new JoystickButton(driverStick, XboxController.Button.kY.value).whenPressed(incrementFeeder, false);
+
+
 
-        JoystickButton turnToYaw = new JoystickButton(driverStick, XboxValue.XBOX_A_BUTTON.getPort());
-        turnToYaw.whenPressed(new TurnToOuterPortCommand(true, Config.maxYawErrorOuterPortCommand.get(), Config.maxTimeOuterPortCommand.get()));
+//        sensitiveDriverControlCommand = new SensitiveDriverControl(driverStick);
+//
+//        JoystickButton turnToYaw = new JoystickButton(driverStick, XboxValue.XBOX_A_BUTTON.getPort());
+//        turnToYaw.whenPressed(new TurnToOuterPortCommand(true, Config.maxYawErrorOuterPortCommand.get(), Config.maxTimeOuterPortCommand.get()));
 
     }
 
diff --git a/src/main/java/frc/robot/commands/ArcadeDriveWithJoystick.java b/src/main/java/frc/robot/commands/ArcadeDriveWithJoystick.java
index cd3e51d..b115f9a 100644
--- a/src/main/java/frc/robot/commands/ArcadeDriveWithJoystick.java
+++ b/src/main/java/frc/robot/commands/ArcadeDriveWithJoystick.java
@@ -23,16 +23,17 @@ public class ArcadeDriveWithJoystick extends ArcadeDrive {
    * @param joy2  The joystick that the second ais is on
    * @param axis2 The second axis
    * @param invert2 Whether to negate the second joystick input
+   * @param squareInputs Whether or not to square inputs
    */
-  public ArcadeDriveWithJoystick(Joystick joy1, int axis1, boolean invert1, Joystick joy2, int axis2, boolean invert2) {
-    super(() -> sign(Config.removeJoystickDeadband(joy1.getRawAxis(axis1)), invert1), () -> sign(Config.removeJoystickDeadband(joy1.getRawAxis(axis2)), invert2), false, true);
+  public ArcadeDriveWithJoystick(Joystick joy1, int axis1, boolean invert1, Joystick joy2, int axis2, boolean invert2, boolean squareInputs) {
+    super(() -> sign(Config.removeJoystickDeadband(joy1.getRawAxis(axis1)), invert1), () -> sign(Config.removeJoystickDeadband(joy1.getRawAxis(axis2)), invert2), squareInputs, false);
   }
   
   /**
    * Creates a new ArcadeDriveWithJoystick with only one Joystick
    */
-  public ArcadeDriveWithJoystick(Joystick joy, int axis1, boolean invert1, int axis2, boolean invert2){
-    this(joy, axis1, invert1, joy, axis2, invert2);
+  public ArcadeDriveWithJoystick(Joystick joy, int axis1, boolean invert1, int axis2, boolean invert2, boolean squareInputs){
+    this(joy, axis1, invert1, joy, axis2, invert2, squareInputs);
   }
 
   // Called once the command ends or is interrupted.
diff --git a/src/main/java/frc/robot/commands/EmptyFeeder.java b/src/main/java/frc/robot/commands/EmptyFeeder.java
index 73d3b1b..a62657d 100644
--- a/src/main/java/frc/robot/commands/EmptyFeeder.java
+++ b/src/main/java/frc/robot/commands/EmptyFeeder.java
@@ -14,6 +14,7 @@ public class EmptyFeeder extends CommandBase {
 
     FeederSubsystem feeder;
 
+
     /**
      * Creates a new FeederSubsystem.
      */
@@ -37,7 +38,7 @@ public class EmptyFeeder extends CommandBase {
     // Called once the command ends or is interrupted.
     @Override
     public void end(boolean interrupted) {
-
+        this.feeder.stopFeeder();
     }
 
 }
\ No newline at end of file
diff --git a/src/main/java/frc/robot/commands/IncrementFeeder.java b/src/main/java/frc/robot/commands/IncrementFeeder.java
index 15e67f9..c225a64 100644
--- a/src/main/java/frc/robot/commands/IncrementFeeder.java
+++ b/src/main/java/frc/robot/commands/IncrementFeeder.java
@@ -18,6 +18,7 @@ public class IncrementFeeder extends CommandBase {
      * Creates a new FeederSubsystem.
      */
     public IncrementFeeder() {
+        System.out.println("Created increment feeder command");
         addRequirements(FeederSubsystem.getInstance());
         this.feeder = FeederSubsystem.getInstance();
     }
@@ -25,19 +26,27 @@ public class IncrementFeeder extends CommandBase {
     // Called when the command is initially scheduled.
     @Override
     public void initialize() {
-        
+        FeederSubsystem.zeroTalon();
     }
 
     // Called every time the scheduler runs while the command is scheduled.
     @Override
     public void execute() {
-        this.feeder.incrementPowerCells();
+        System.out.println("Executing incrementing command!");
+     //   feeder.runFeeder();
+     //   this.feeder.incrementPowerCells();
     }
 
     // Called once the command ends or is interrupted.
     @Override
     public void end(boolean interrupted) {
-        
+        System.out.println("Ending command..");
+        this.feeder.stopFeeder();
+    }
+
+    @Override
+    public boolean isFinished() {
+        return feeder.doneIncrementing();
     }
 
 }
\ No newline at end of file
diff --git a/src/main/java/frc/robot/commands/MoveArmManuallyCommand.java b/src/main/java/frc/robot/commands/MoveArmManuallyCommand.java
new file mode 100644
index 0000000..cba8eee
--- /dev/null
+++ b/src/main/java/frc/robot/commands/MoveArmManuallyCommand.java
@@ -0,0 +1,64 @@
+package frc.robot.commands;
+
+import edu.wpi.first.wpilibj2.command.CommandBase;
+import frc.robot.subsystems.ArmSubsystem;
+
+
+public class MoveArmManuallyCommand extends CommandBase {
+    private final ArmSubsystem armSubsystem;
+
+    public MoveArmManuallyCommand() {
+        addRequirements(ArmSubsystem.getInstance());
+        armSubsystem = ArmSubsystem.getInstance();
+    }
+
+    /**
+     * The initial subroutine of a command.  Called once when the command is initially scheduled.
+     */
+    @Override
+    public void initialize() {
+
+    }
+
+    /**
+     * The main body of a command.  Called repeatedly while the command is scheduled.
+     * (That is, it is called repeatedly until {@link #isFinished()}) returns true.)
+     */
+    @Override
+    public void execute() {
+        armSubsystem.moveArm(0.7);
+    }
+
+    /**
+     * <p>
+     * Returns whether this command has finished. Once a command finishes -- indicated by
+     * this method returning true -- the scheduler will call its {@link #end(boolean)} method.
+     * </p><p>
+     * Returning false will result in the command never ending automatically. It may still be
+     * cancelled manually or interrupted by another command. Hard coding this command to always
+     * return true will result in the command executing once and finishing immediately. It is
+     * recommended to use * {@link edu.wpi.first.wpilibj2.command.InstantCommand InstantCommand}
+     * for such an operation.
+     * </p>
+     *
+     * @return whether this command has finished.
+     */
+    @Override
+    public boolean isFinished() {
+        // TODO: Make this return true when this Command no longer needs to run execute()
+        return false;
+    }
+
+    /**
+     * The action to take when the command ends. Called when either the command
+     * finishes normally -- that is it is called when {@link #isFinished()} returns
+     * true -- or when  it is interrupted/canceled. This is where you may want to
+     * wrap up loose ends, like shutting off a motor that was being used in the command.
+     *
+     * @param interrupted whether the command was interrupted/canceled
+     */
+    @Override
+    public void end(boolean interrupted) {
+        armSubsystem.moveArm(0d);
+    }
+}
diff --git a/src/main/java/frc/robot/commands/ReverseFeeder.java b/src/main/java/frc/robot/commands/ReverseFeeder.java
new file mode 100644
index 0000000..b7aea72
--- /dev/null
+++ b/src/main/java/frc/robot/commands/ReverseFeeder.java
@@ -0,0 +1,43 @@
+/*----------------------------------------------------------------------------*/
+/* Copyright (c) 2019 FIRST. All Rights Reserved.                             */
+/* Open Source Software - may be modified and shared by FRC teams. The code   */
+/* must be accompanied by the FIRST BSD license file in the root directory of */
+/* the project.                                                               */
+/*----------------------------------------------------------------------------*/
+
+package frc.robot.commands;
+
+import edu.wpi.first.wpilibj2.command.CommandBase;
+import frc.robot.subsystems.FeederSubsystem;
+
+public class ReverseFeeder extends CommandBase {
+
+    FeederSubsystem feeder;
+    
+    /**
+     * Creates a new FeederSubsystem.
+     */
+    public ReverseFeeder() {
+        addRequirements(FeederSubsystem.getInstance());
+        this.feeder = FeederSubsystem.getInstance();
+    }
+
+    // Called when the command is initially scheduled.
+    @Override
+    public void initialize() {
+
+    }
+
+    // Called every time the scheduler runs while the command is scheduled.
+    @Override
+    public void execute() {
+        this.feeder.reverseFeeder();
+    }
+
+    // Called once the command ends or is interrupted.
+    @Override
+    public void end(boolean interrupted) {
+        this.feeder.stopFeeder();
+    }
+
+}
\ No newline at end of file
diff --git a/src/main/java/frc/robot/commands/SpinUpShooter.java b/src/main/java/frc/robot/commands/SpinUpShooter.java
index b8c6a30..b3beed6 100644
--- a/src/main/java/frc/robot/commands/SpinUpShooter.java
+++ b/src/main/java/frc/robot/commands/SpinUpShooter.java
@@ -9,7 +9,7 @@ public class SpinUpShooter extends CommandBase {
   private ShooterSubsystem shooterSubsystem;
 
   boolean doneRamping;
-  int RPM = 2000;
+  int RPM = 1000;
 
   public SpinUpShooter() {
     shooterSubsystem = ShooterSubsystem.getInstance();
@@ -25,7 +25,8 @@ public class SpinUpShooter extends CommandBase {
   @Override
   public void execute() {
     shooterSubsystem.setTargetRPM(RPM);
-    SmartDashboard.putNumber("shooter RPM", shooterSubsystem.getRPM());
+    SmartDashboard.putNumber("Shooter RPM", shooterSubsystem.getRPM());
+    SmartDashboard.putNumber("Shooter motor temp", shooterSubsystem.getTemperature());
     doneRamping = shooterSubsystem.isAtTargetRPM();
     if(doneRamping){
       // Print to console
diff --git a/src/main/java/frc/robot/commands/TurnToOuterPortCommand.java b/src/main/java/frc/robot/commands/TurnToOuterPortCommand.java
index 3ae7fde..f58d9f9 100644
--- a/src/main/java/frc/robot/commands/TurnToOuterPortCommand.java
+++ b/src/main/java/frc/robot/commands/TurnToOuterPortCommand.java
@@ -53,14 +53,17 @@ public class TurnToOuterPortCommand extends CommandBase {
     public void execute() {
         // Filter out the default value
         DrivetrainPIDTurnDelta drivetrainPIDTurnDelta;
-        if (currentTarget != -1) {
-            // Check if the yaw should be inverted (Shooter is on the back so we may need to)
-            if (invert) {
-                drivetrainPIDTurnDelta = new DrivetrainPIDTurnDelta(-currentTarget, 0, acceptableError, maxTime);
-            } else {
-                drivetrainPIDTurnDelta = new DrivetrainPIDTurnDelta(currentTarget, 0, acceptableError, maxTime);
+        if (currentTarget != -99) {
+            // Filter out outlying values
+            if(currentTarget >= 30 && currentTarget <= -30) {
+                // Check if the yaw should be inverted (Shooter is on the back so we may need to)
+                if (invert) {
+                    drivetrainPIDTurnDelta = new DrivetrainPIDTurnDelta(-currentTarget, 0, acceptableError, maxTime);
+                } else {
+                    drivetrainPIDTurnDelta = new DrivetrainPIDTurnDelta(currentTarget, 0, acceptableError, maxTime);
+                }
+                drivetrainPIDTurnDelta.schedule();
             }
-            drivetrainPIDTurnDelta.schedule();
         } else {
             // Ensure no movement on faulty values
             drivetrainPIDTurnDelta = new DrivetrainPIDTurnDelta(0, 0, 0d, 0d);
diff --git a/src/main/java/frc/robot/config/Config.java b/src/main/java/frc/robot/config/Config.java
index 0f9c2ce..7b17fad 100644
--- a/src/main/java/frc/robot/config/Config.java
+++ b/src/main/java/frc/robot/config/Config.java
@@ -76,6 +76,8 @@ public class Config {
     public static int LEFT_REAR_MOTOR = robotSpecific(3, 3, 2, 3, 3);
     public static int INTAKE_MOTOR = robotSpecific(6, 6, -1, 6, -1);
     public static int SHOOTER_MOTOR = robotSpecific(5, 5, -1, -1, 16); //protobot is 16
+    public static int CLIMBER_TALON = robotSpecific(10, 10, -1, -1, 16);
+
 
     public static int TALON_5_PLYBOY = robotSpecific(-1, -1, -1, -1, -1, 5);
     
@@ -96,14 +98,14 @@ public class Config {
     public static int RIGHT_CONTROL_STICK_Y = 5;
     public static int RIGHT_CONTROL_STICK_X = 4;
     
-    public static boolean INVERT_FIRST_AXIS = robotSpecific(true, true, true);
-    public static boolean INVERT_SECOND_AXIS = robotSpecific(true, true, true);
+    public static boolean INVERT_FIRST_AXIS = robotSpecific(false, true, true);
+    public static boolean INVERT_SECOND_AXIS = robotSpecific(false, true, true);
     
     public static double CONTROLLER_DEADBAND = 0.05;
     
     public static double CURVATURE_OVERRIDE = 0.25;
     
-    public static boolean INVERT_ARM_TALON = robotSpecific(false, false, false);
+    public static boolean INVERT_ARM_TALON = robotSpecific(true, false, false);
     
     public static int ARM_ALLOWABLE_CLOSED_LOOP_ERROR_TICKS = 4096;
     
@@ -116,9 +118,9 @@ public class Config {
     public static final boolean TELEOP_SQUARE_JOYSTICK_INPUTS = true;
     
     // PIDF values for the arm
-    public static double ARM_PID_P = robotSpecific(0.2);
+    public static double ARM_PID_P = robotSpecific(0.0);
     public static double ARM_PID_I = robotSpecific(0.0);
-    public static double ARM_PID_D = robotSpecific(0.1);
+    public static double ARM_PID_D = robotSpecific(0.0);
     public static double ARM_PID_F = robotSpecific(0.0);
     
     // Define a global constants table for subsystems to use
diff --git a/src/main/java/frc/robot/nettables/VisionCtrlNetTable.java b/src/main/java/frc/robot/nettables/VisionCtrlNetTable.java
index 6ce921c..1a80935 100644
--- a/src/main/java/frc/robot/nettables/VisionCtrlNetTable.java
+++ b/src/main/java/frc/robot/nettables/VisionCtrlNetTable.java
@@ -36,7 +36,7 @@ public class VisionCtrlNetTable {
         mergeVisionTable = inst.getTable(Config.VISION_TABLE_NAME);
         distanceToPowerCell = () -> mergeVisionTable.getEntry(Config.DISTANCE_POWERCELL).getDouble(-1);
         yawToPowerCell = () -> mergeVisionTable.getEntry(Config.YAW_POWERCELL).getDouble(-1);
-        yawToOuterPort = () -> mergeVisionTable.getEntry(Config.YAW_OUTER_PORT).getDouble(-1);
+        yawToOuterPort = () -> mergeVisionTable.getEntry(Config.YAW_OUTER_PORT).getDouble(-99);
 
 
 
diff --git a/src/main/java/frc/robot/subsystems/ArmSubsystem.java b/src/main/java/frc/robot/subsystems/ArmSubsystem.java
index 7281d2c..318e69d 100644
--- a/src/main/java/frc/robot/subsystems/ArmSubsystem.java
+++ b/src/main/java/frc/robot/subsystems/ArmSubsystem.java
@@ -1,14 +1,18 @@
 package frc.robot.subsystems;
 
 import com.ctre.phoenix.ErrorCode;
+import com.ctre.phoenix.motorcontrol.ControlMode;
 import com.ctre.phoenix.motorcontrol.FeedbackDevice;
 import com.ctre.phoenix.motorcontrol.NeutralMode;
 import com.ctre.phoenix.motorcontrol.StatusFrame;
 import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
+import edu.wpi.first.wpilibj.DriverStation;
 import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
 import edu.wpi.first.wpilibj2.command.SubsystemBase;
 import frc.robot.config.Config;
 
+import javax.naming.ldap.Control;
+
 public class ArmSubsystem extends ConditionalSubsystemBase {
 
     // TODO Change placeholder values to actual limits
@@ -21,6 +25,11 @@ public class ArmSubsystem extends ConditionalSubsystemBase {
     WPI_TalonSRX armTalon;
     ErrorCode errorCode;
 
+    private static final int[] setpoints = {
+            1000,
+            3000,
+        };
+
 
     private ArmSubsystem() {
 
@@ -34,47 +43,47 @@ public class ArmSubsystem extends ConditionalSubsystemBase {
         armTalon.setNeutralMode(NeutralMode.Coast);
 
         // Setup the talon, recording the error code
-        errorCode = armTalon.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Relative,
+        errorCode = armTalon.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Absolute,
                 0, Config.CAN_TIMEOUT_SHORT);
 
-        armTalon.setSelectedSensorPosition(0);
+        SmartDashboard.putNumber("Arm Error Code", errorCode.value);
 
         armTalon.setInverted(Config.INVERT_ARM_TALON);
 
-        /* Config the peak and nominal outputs, 12V means full */
-        armTalon.configNominalOutputForward(0, Config.CAN_TIMEOUT_SHORT);
-        armTalon.configNominalOutputReverse(0, Config.CAN_TIMEOUT_SHORT);
-        armTalon.configPeakOutputForward(1, Config.CAN_TIMEOUT_SHORT);
-        armTalon.configPeakOutputReverse(-1, Config.CAN_TIMEOUT_SHORT);
-
-        armTalon.configAllowableClosedloopError(0, Config.ARM_ALLOWABLE_CLOSED_LOOP_ERROR_TICKS, Config.CAN_TIMEOUT_SHORT);
-
+//        /* Config the peak and nominal outputs, 12V means full */
+//        armTalon.configNominalOutputForward(0, Config.CAN_TIMEOUT_SHORT);
+//        armTalon.configNominalOutputReverse(0, Config.CAN_TIMEOUT_SHORT);
+//        armTalon.configPeakOutputForward(1, Config.CAN_TIMEOUT_SHORT);
+//        armTalon.configPeakOutputReverse(-1, Config.CAN_TIMEOUT_SHORT);
+//
+//        armTalon.configAllowableClosedloopError(0, Config.ARM_ALLOWABLE_CLOSED_LOOP_ERROR_TICKS, Config.CAN_TIMEOUT_SHORT);
+//
         //  Config the PID Values based on constants
         armTalon.config_kP(0, Config.ARM_PID_P, Config.CAN_TIMEOUT_SHORT);
         armTalon.config_kI(0, Config.ARM_PID_I, Config.CAN_TIMEOUT_SHORT);
         armTalon.config_kD(0, Config.ARM_PID_D, Config.CAN_TIMEOUT_SHORT);
-        armTalon.config_kF(0, Config.ARM_PID_F, Config.CAN_TIMEOUT_SHORT);
 
-        // Set up the close loop period
-        armTalon.configClosedLoopPeriod(0, Config.CAN_TIMEOUT_LONG);
-        armTalon.setSensorPhase(true);
-        armTalon.setStatusFramePeriod(StatusFrame.Status_12_Feedback1, 20, Config.CAN_TIMEOUT_LONG);
-        armTalon.setStatusFramePeriod(StatusFrame.Status_13_Base_PIDF0, 20, Config.CAN_TIMEOUT_LONG);
+//
+//        // Set up the close loop period
+//        armTalon.configClosedLoopPeriod(0, Config.CAN_TIMEOUT_LONG);
+//        armTalon.setSensorPhase(true);
+       // armTalon.setStatusFramePeriod(StatusFrame.Status_12_Feedback1, 20, Config.CAN_TIMEOUT_LONG);
+        //armTalon.setStatusFramePeriod(StatusFrame.Status_13_Base_PIDF0, 20, Config.CAN_TIMEOUT_LONG);
 
         // Enable forward soft limit and set the value in encoder ticks
-        armTalon.configForwardSoftLimitEnable(true);
-        armTalon.configForwardSoftLimitThreshold(FORWARD_LIMIT_TICKS, Config.CAN_TIMEOUT_LONG);
+   //     armTalon.configForwardSoftLimitEnable(true);
+     //   armTalon.configForwardSoftLimitThreshold(FORWARD_LIMIT_TICKS, Config.CAN_TIMEOUT_LONG);
 
         // Enable reverse soft limit and set the value in encoder ticks
-        armTalon.configReverseSoftLimitEnable(true);
-        armTalon.configReverseSoftLimitThreshold(REVERSE_LIMIT_TICKS, Config.CAN_TIMEOUT_LONG);
+//        armTalon.configReverseSoftLimitEnable(true);
+//        armTalon.configReverseSoftLimitThreshold(REVERSE_LIMIT_TICKS, Config.CAN_TIMEOUT_LONG);
 
         // Max voltage to apply with the talon. 12 is the maximum
-        armTalon.configVoltageCompSaturation(12, Config.CAN_TIMEOUT_LONG);
-        armTalon.enableVoltageCompensation(true);
+     //   armTalon.configVoltageCompSaturation(12, Config.CAN_TIMEOUT_LONG);
+       // armTalon.enableVoltageCompensation(true);
 
         // Number of seconds from 0 to full throttle
-        armTalon.configOpenloopRamp(0.6, Config.CAN_TIMEOUT_LONG);
+  //      armTalon.configOpenloopRamp(0.6, Config.CAN_TIMEOUT_LONG);
 
         createCondition("talonFunctional", SubsystemConditionStates.ALWAYS);
 
@@ -100,11 +109,45 @@ public class ArmSubsystem extends ConditionalSubsystemBase {
     public void zeroTalonEncoder() {
         armTalon.setSelectedSensorPosition(0);
     }
+
+    public void setpoint(int setpointIndex) {
+        if(setpointIndex < setpoints.length) {
+            armTalon.set(ControlMode.Position, setpointIndex);
+        } else {
+            DriverStation.reportError("Invalid arm position [Array index out of bounds]", false);
+        }
+    }
+
+    public void moveArm(double speed) {
+        armTalon.set(speed);
+    }
     
     @Override
     public void periodic() {
         super.periodic();
 
-        SmartDashboard.putNumber("Arm Motor Ticks", armTalon.getSelectedSensorPosition(0));
+      //  armTalon.config_kF(0, 4.186 * Math.cos(toDeg(armTalon.getSelectedSensorPosition())), Config.CAN_TIMEOUT_SHORT);
+
+     //   armTalon.setVoltage(4.186 * Math.toDegrees(Math.cos(toDeg(armTalon.getSelectedSensorPosition()))));
+
+     //   System.out.println("Arm encoder ticks" + armTalon.getSensorCollection().getQuadraturePosition());
+
+        SmartDashboard.putNumber("Arm Motor Ticks", armTalon.getSelectedSensorPosition());
+        SmartDashboard.putNumber("Arm Angle", toDeg(armTalon.getSelectedSensorPosition()));
+    }
+
+    /**
+     * @param units CTRE mag encoder sensor units
+     * @return degrees rounded to tenths.
+     */
+    Double toDeg(int units) {
+        double deg = units * 360.0 / 4096.0;
+
+        /* truncate to 0.1 res */
+        deg *= 10;
+        deg = (int) deg;
+        deg /= 10;
+
+        return deg;
     }
 }
diff --git a/src/main/java/frc/robot/subsystems/DriveBase.java b/src/main/java/frc/robot/subsystems/DriveBase.java
index 49aac43..36865e1 100644
--- a/src/main/java/frc/robot/subsystems/DriveBase.java
+++ b/src/main/java/frc/robot/subsystems/DriveBase.java
@@ -9,6 +9,7 @@ package frc.robot.subsystems;
 
 import com.ctre.phoenix.motorcontrol.FeedbackDevice;
 import com.ctre.phoenix.motorcontrol.NeutralMode;
+import com.ctre.phoenix.motorcontrol.can.VictorSPX;
 import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
 import com.ctre.phoenix.sensors.PigeonIMU;
 import edu.wpi.first.wpilibj.drive.DifferentialDrive;
@@ -35,7 +36,12 @@ public class DriveBase extends SubsystemBase {
     private DriveMode driveMode;
 
     // The drivebase talons
-    private WPI_TalonSRX leftFrontTalon, leftRearTalon, rightFrontTalon, rightRearTalon, talon5plyboy;
+    private WPI_TalonSRX leftFrontTalon, rightFrontTalon, talon5plyboy;
+
+    // Will be moved later
+    private WPI_TalonSRX climberTalon = new WPI_TalonSRX(Config.CLIMBER_TALON);
+
+    private VictorSPX leftRearVictor, rightRearVictor;
 
     public boolean sensitiveSteering = false;
 
@@ -48,9 +54,9 @@ public class DriveBase extends SubsystemBase {
 
         // Initialize the talons
         leftFrontTalon = new WPI_TalonSRX(Config.LEFT_FRONT_MOTOR);
-        leftRearTalon = new WPI_TalonSRX(Config.LEFT_REAR_MOTOR);
+        leftRearVictor = new VictorSPX(Config.LEFT_REAR_MOTOR);
         rightFrontTalon = new WPI_TalonSRX(Config.RIGHT_FRONT_MOTOR);
-        rightRearTalon = new WPI_TalonSRX(Config.RIGHT_REAR_MOTOR);
+        rightRearVictor = new VictorSPX(Config.RIGHT_REAR_MOTOR);
 
         SmartDashboard.putNumber("Right Front Talon", Config.RIGHT_FRONT_MOTOR);
 
@@ -60,9 +66,10 @@ public class DriveBase extends SubsystemBase {
 
         robotDriveBase = new DifferentialDrive(leftFrontTalon, rightFrontTalon);
 
-        var pigeonTalon = Config.robotSpecific(null, null, rightRearTalon, leftFrontTalon, leftRearTalon, talon5plyboy);
-        if(pigeonTalon != null){
-            _pidgey = new PigeonIMU (pigeonTalon);
+        var pigeonTalon = Config.robotSpecific(climberTalon, null, rightRearVictor, leftFrontTalon, leftRearVictor, talon5plyboy);
+        if(pigeonTalon != null) {
+            // Hardcoded for testing
+            _pidgey = new PigeonIMU (climberTalon);
             _pidgey.setFusedHeading(0.0, 30);
         }
 
@@ -121,8 +128,8 @@ public class DriveBase extends SubsystemBase {
      * Make the back talons follow the front talons
      */
     private void follow() {
-        leftRearTalon.follow(leftFrontTalon);
-        rightRearTalon.follow(rightFrontTalon);
+        leftRearVictor.follow(leftFrontTalon);
+        rightRearVictor.follow(rightFrontTalon);
     }
 
     /**
@@ -160,8 +167,6 @@ public class DriveBase extends SubsystemBase {
      */
     public void stop() {
         leftFrontTalon.stopMotor();
-        leftRearTalon.stopMotor();
-        rightRearTalon.stopMotor();
         rightFrontTalon.stopMotor();
     }
 
@@ -189,9 +194,9 @@ public class DriveBase extends SubsystemBase {
         NeutralMode mode = brake ? NeutralMode.Brake : NeutralMode.Coast;
 
         leftFrontTalon.setNeutralMode(mode);
-        leftRearTalon.setNeutralMode(mode);
+        leftRearVictor.setNeutralMode(mode);
         rightFrontTalon.setNeutralMode(mode);
-        rightRearTalon.setNeutralMode(mode);
+        rightRearVictor.setNeutralMode(mode);
 
         brakeMode = brake;
     }
@@ -201,17 +206,17 @@ public class DriveBase extends SubsystemBase {
      */
     private void selectEncoderStandard() {
         leftFrontTalon.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Relative);
-        leftRearTalon.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Relative);
+        leftRearVictor.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Relative);
         rightFrontTalon.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Relative);
-        rightRearTalon.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Relative);
+        rightRearVictor.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Relative);
 
         leftFrontTalon.configNeutralDeadband(Config.DRIVE_OPEN_LOOP_DEADBAND);
-        leftRearTalon.configNeutralDeadband(Config.DRIVE_OPEN_LOOP_DEADBAND);
+        leftRearVictor.configNeutralDeadband(Config.DRIVE_OPEN_LOOP_DEADBAND);
         rightFrontTalon.configNeutralDeadband(Config.DRIVE_OPEN_LOOP_DEADBAND);
-        rightRearTalon.configNeutralDeadband(Config.DRIVE_OPEN_LOOP_DEADBAND);
+        rightRearVictor.configNeutralDeadband(Config.DRIVE_OPEN_LOOP_DEADBAND);
 
         SmartDashboard.putNumber("Left Front", leftFrontTalon.getDeviceID());
-        SmartDashboard.putNumber("Left Back", leftRearTalon.getDeviceID());
+        SmartDashboard.putNumber("Left Back", leftRearVictor.getDeviceID());
         SmartDashboard.putNumber("Right Front", rightFrontTalon.getDeviceID());
         SmartDashboard.putNumber("Right Back", leftFrontTalon.getDeviceID());
 
@@ -221,14 +226,12 @@ public class DriveBase extends SubsystemBase {
      * Reset the talons to factory default
      */
     private void resetTalons() {
-        leftRearTalon.configFactoryDefault(Config.CAN_TIMEOUT_LONG);
+        leftRearVictor.configFactoryDefault(Config.CAN_TIMEOUT_LONG);
         leftFrontTalon.configFactoryDefault(Config.CAN_TIMEOUT_LONG);
         rightFrontTalon.configFactoryDefault(Config.CAN_TIMEOUT_LONG);
-        rightRearTalon.configFactoryDefault(Config.CAN_TIMEOUT_LONG);
+        rightRearVictor.configFactoryDefault(Config.CAN_TIMEOUT_LONG);
 
-        leftRearTalon.configPeakCurrentLimit(2, Config.CAN_TIMEOUT_LONG);
         leftFrontTalon.configPeakCurrentLimit(2, Config.CAN_TIMEOUT_LONG);
-        rightRearTalon.configPeakCurrentLimit(2, Config.CAN_TIMEOUT_LONG);
         rightFrontTalon.configPeakCurrentLimit(2, Config.CAN_TIMEOUT_LONG);
     }
 
diff --git a/src/main/java/frc/robot/subsystems/FeederSubsystem.java b/src/main/java/frc/robot/subsystems/FeederSubsystem.java
index 744247d..82396d6 100644
--- a/src/main/java/frc/robot/subsystems/FeederSubsystem.java
+++ b/src/main/java/frc/robot/subsystems/FeederSubsystem.java
@@ -9,9 +9,11 @@ package frc.robot.subsystems;
 
 import com.ctre.phoenix.motorcontrol.ControlMode;
 import com.ctre.phoenix.motorcontrol.FeedbackDevice;
+import com.ctre.phoenix.motorcontrol.TalonSRXFeedbackDevice;
 import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
 
 import edu.wpi.first.wpilibj.AnalogInput;
+import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
 import frc.robot.config.Config;
 import frc.robot.config.FluidConstant;
 
@@ -32,21 +34,21 @@ public class FeederSubsystem extends ConditionalSubsystemBase {
     private static AnalogInput indexerIrSensor;
 
     //How much to shift the feeder wheel when incrementing
-    public static FluidConstant<Double> FEEDERSUBSYSTEM_INCREMENT_TICKS = new FluidConstant<>("IncrementTicks", 0.0)
+    public static FluidConstant<Double> FEEDERSUBSYSTEM_INCREMENT_TICKS = new FluidConstant<>("IncrementTicks", 1200.0)
                 .registerToTable(Config.constantsTable);
     //Max distance at which the robot knows a ball is at the indexer
     public static FluidConstant<Integer> FEEDERSUBSYSTEM_IR_MAX_DISTANCE = new FluidConstant<>("IrMaxDistance", 0)
                 .registerToTable(Config.constantsTable);
-    public static FluidConstant<Double> FEEDERSUBSYSTEM_P = new FluidConstant<>("FeederSubsystemP", 0.0)
+    public static FluidConstant<Double> FEEDERSUBSYSTEM_P = new FluidConstant<>("FeederSubsystemP", 0.1)
                 .registerToTable(Config.constantsTable);
     public static FluidConstant<Double> FEEDERSUBSYSTEM_I = new FluidConstant<>("FeederSubsystemI", 0.0)
                 .registerToTable(Config.constantsTable);
-    public static FluidConstant<Double> FEEDERSUBSYSTEM_D = new FluidConstant<>("FeederSubsystemD", 0.0)
+    public static FluidConstant<Double> FEEDERSUBSYSTEM_D = new FluidConstant<>("FeederSubsystemD", 0.05)
                 .registerToTable(Config.constantsTable);
     public static FluidConstant<Double> FEEDERSUBSYSTEM_F = new FluidConstant<>("FeederSubsystemF", 0.0)
                 .registerToTable(Config.constantsTable);
     //Highest speed the motor could reach
-    public static FluidConstant<Double> FEEDERSUBSYSTEM_PEAK_OUTPUT = new FluidConstant<>("FeederSubsystemPeakOutput", 0.0) 
+    public static FluidConstant<Double> FEEDERSUBSYSTEM_PEAK_OUTPUT = new FluidConstant<>("FeederSubsystemPeakOutput", 0.35)
                 .registerToTable(Config.constantsTable);
 
     private final int kTimeoutMs = 1000;
@@ -58,7 +60,7 @@ public class FeederSubsystem extends ConditionalSubsystemBase {
         createCondition("encoderHealthy", SubsystemConditionStates.ALWAYS);
 
         //Initialize the talon
-        //feederTalon = new WPI_TalonSRX(Config.FEEDER_SUBSYSTEM_TALON);
+        feederTalon = new WPI_TalonSRX(Config.FEEDER_SUBSYSTEM_TALON);
 
         //Initialize the IR sensor
         //indexerIrSensor = new AnalogInput(Config.FEEDERSUBSYSTEM_IR_SENSOR);
@@ -71,19 +73,25 @@ public class FeederSubsystem extends ConditionalSubsystemBase {
             feederTalon.configNominalOutputForward(0, kTimeoutMs);
             feederTalon.configNominalOutputReverse(0, kTimeoutMs);
             feederTalon.configPeakOutputForward(FEEDERSUBSYSTEM_PEAK_OUTPUT.get(), kTimeoutMs);
-            feederTalon.configPeakOutputReverse(-FEEDERSUBSYSTEM_PEAK_OUTPUT.get(), kTimeoutMs);
+            feederTalon.configPeakOutputReverse(-(FEEDERSUBSYSTEM_PEAK_OUTPUT.get()), kTimeoutMs);
             feederTalon.configAllowableClosedloopError(0, 0, kTimeoutMs);
             feederTalon.config_kF(kPIDLoopIdx, FEEDERSUBSYSTEM_F.get(), kTimeoutMs);
             feederTalon.config_kP(kPIDLoopIdx, FEEDERSUBSYSTEM_P.get(), kTimeoutMs);
             feederTalon.config_kI(kPIDLoopIdx, FEEDERSUBSYSTEM_I.get(), kTimeoutMs);
             feederTalon.config_kD(kPIDLoopIdx, FEEDERSUBSYSTEM_D.get(), kTimeoutMs);
-            int absolutePosition = feederTalon.getSensorCollection().getPulseWidthPosition();
-            feederTalon.setSelectedSensorPosition(absolutePosition, kPIDLoopIdx, kTimeoutMs);
-            feederTalon.setSelectedSensorPosition(0, 0, 10);
+            feederTalon.configAllowableClosedloopError(0, 100, Config.CAN_TIMEOUT_SHORT);
+        //    int absolutePosition = feederTalon.getSensorCollection().getPulseWidthPosition();
+            feederTalon.setSelectedSensorPosition(0, 0, Config.CAN_TIMEOUT_SHORT);
+        //    feederTalon.configSelectedFeedbackSensor(TalonSRXFeedbackDevice.CTRE_MagEncoder_Relative, 0, Config.CAN_TIMEOUT_SHORT);
+
         }
 
     }
 
+    public static void zeroTalon() {
+        feederTalon.getSensorCollection().setQuadraturePosition(0, Config.CAN_TIMEOUT_SHORT);
+    }
+
     public static void init() {
         if (currentInstance == null) {
             currentInstance = new FeederSubsystem();
@@ -99,7 +107,8 @@ public class FeederSubsystem extends ConditionalSubsystemBase {
      * Moves the power cells along the feeder track a certain amount
      */
     public void incrementPowerCells(){
-        feederTalon.setSelectedSensorPosition(0, 0, 10);
+        System.out.println("Incrementing power cells...");
+
         feederTalon.set(ControlMode.Position, FEEDERSUBSYSTEM_INCREMENT_TICKS.get());
     }
 
@@ -114,8 +123,12 @@ public class FeederSubsystem extends ConditionalSubsystemBase {
     /**
      * Runs the feeder motor at a certain speed
      */
-    public void runFeeder(){
-        feederTalon.set(FEEDERSUBSYSTEM_PEAK_OUTPUT.get());
+    public void runFeeder() {
+        feederTalon.set(ControlMode.PercentOutput, FEEDERSUBSYSTEM_PEAK_OUTPUT.get());
+    }
+
+    public void reverseFeeder(){
+        feederTalon.set(ControlMode.PercentOutput, -FEEDERSUBSYSTEM_PEAK_OUTPUT.get());
     }
 
     /**
@@ -126,8 +139,29 @@ public class FeederSubsystem extends ConditionalSubsystemBase {
         feederTalon.set(ControlMode.Position, 6*FEEDERSUBSYSTEM_INCREMENT_TICKS.get());
     }
 
+    /**
+     * Determines if the lift has reached the given setpoint.
+     *
+     * @return True if the lift has reached the setpoint, false otherwise.
+     */
+    public boolean doneIncrementing() {
+        boolean done = false;
+
+        if(feederTalon.getSelectedSensorPosition() >= FEEDERSUBSYSTEM_INCREMENT_TICKS.get() - 100 && feederTalon.getSelectedSensorPosition() <= feederTalon.getSelectedSensorPosition() + 100) {
+            done = true;
+        }
+        return done;
+    }
+
+
     public void periodic() {
       // Set the default command for a subsystem here.
       // setDefaultCommand(new MySpecialCommand());
+        SmartDashboard.putNumber("Feeder encoder ticks", feederTalon.getSelectedSensorPosition());
+    }
+
+    public void stopFeeder() {
+        feederTalon.stopMotor();
     }
+
 }
\ No newline at end of file
diff --git a/src/main/java/frc/robot/subsystems/IntakeSubsystem.java b/src/main/java/frc/robot/subsystems/IntakeSubsystem.java
index fcddd05..b56a426 100644
--- a/src/main/java/frc/robot/subsystems/IntakeSubsystem.java
+++ b/src/main/java/frc/robot/subsystems/IntakeSubsystem.java
@@ -1,6 +1,7 @@
 package frc.robot.subsystems;
 
 import com.ctre.phoenix.motorcontrol.ControlMode;
+import com.ctre.phoenix.motorcontrol.can.TalonSRX;
 import com.ctre.phoenix.motorcontrol.can.VictorSPX;
 import edu.wpi.first.wpilibj2.command.SubsystemBase;
 import frc.robot.config.Config;
@@ -14,11 +15,11 @@ public class IntakeSubsystem extends ConditionalSubsystemBase {
     private final static IntakeSubsystem INSTANCE = new IntakeSubsystem();
 
     // The supplier of the intake speed
-    private final static FluidConstant<Double> INTAKE_SPEED = new FluidConstant<>("intake-target-speed", 0.25d)
+    private final static FluidConstant<Double> INTAKE_SPEED = new FluidConstant<>("intake-target-speed", 0.80d)
             .registerToTable(Config.constantsTable);
 
     // The intake motor (if any)
-    private VictorSPX intakeMotor;
+    private TalonSRX intakeMotor;
 
     /**
      * Creates a new instance of this IntakeSubsystem.
@@ -26,10 +27,14 @@ public class IntakeSubsystem extends ConditionalSubsystemBase {
      * should use the {@link #getInstance()} method to get the instance.
      */
     private IntakeSubsystem() {
+
         createCondition("operatorActivated", SubsystemConditionStates.TELEOP);
         if (Config.INTAKE_MOTOR != -1) {
-            intakeMotor = new VictorSPX(Config.INTAKE_MOTOR);
+            intakeMotor = new TalonSRX(Config.INTAKE_MOTOR);
         }
+
+        intakeMotor.setInverted(true);
+
     }
 
     /**
diff --git a/src/main/java/frc/robot/subsystems/ShooterSubsystem.java b/src/main/java/frc/robot/subsystems/ShooterSubsystem.java
index 6af6eff..37625db 100644
--- a/src/main/java/frc/robot/subsystems/ShooterSubsystem.java
+++ b/src/main/java/frc/robot/subsystems/ShooterSubsystem.java
@@ -19,16 +19,16 @@ public class ShooterSubsystem extends SubsystemBase {
 
   // PID values (currently set for protobot's shooter)
   public static FluidConstant<Double> P_SHOOTERSUBSYSTEM = new FluidConstant<>
-    ("P_ShooterSubsystem", 0.0003).registerToTable(Config.constantsTable);
+    ("P_ShooterSubsystem", 0.002).registerToTable(Config.constantsTable);
 
   public static FluidConstant<Double> I_SHOOTERSUBSYSTEM = new FluidConstant<>
     ("I_ShooterSubsystem", 0.0).registerToTable(Config.constantsTable);
 
   public static FluidConstant<Double> D_SHOOTERSUBSYSTEM = new FluidConstant<>
-    ("D_ShooterSubsystem", 0.0001).registerToTable(Config.constantsTable);
+    ("D_ShooterSubsystem", 0.0002).registerToTable(Config.constantsTable);
 
   public static FluidConstant<Double> F_SHOOTERSUBSYSTEM = new FluidConstant<>
-    ("F_ShooterSubsystem", 0.00018).registerToTable(Config.constantsTable);
+    ("F_ShooterSubsystem", 0.00027).registerToTable(Config.constantsTable);
 
   public static FluidConstant<Integer> SETPOINT_RPM = new FluidConstant<>
     ("setpointRPM", 0).registerToTable(Config.constantsTable);
@@ -60,6 +60,9 @@ public class ShooterSubsystem extends SubsystemBase {
     m_pidController = m_shooter.getPIDController();
     m_encoder = m_shooter.getEncoder();
 
+    // Set the shooter to spin in the right direction
+    m_shooter.setInverted(true);
+
     m_pidController.setOutputRange(kMinOutput, kMaxOutput);
 
     m_pidController.setFF(F_SHOOTERSUBSYSTEM.get());
